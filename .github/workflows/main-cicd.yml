name: 415-hha_cbr/cbr-platform

# TODO:
# - fix clone depth
# - checkout the exact commit GitHub wants us to (not necessarily the head on main!)
# - move checkout into sub-action to reduce duplicate code
# - Add Caddyfile check to caddy/Dockerfile: RUN caddy validate --config /etc/caddy/Caddyfile


on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
env:
  HUB_REPO_BACKEND: "${{ secrets.HUB_REPO_BACKEND }}"
  HUB_REPO_FRONTEND: "${{ secrets.HUB_REPO_FRONTEND }}"
  HUB_TOKEN: "${{ secrets.HUB_TOKEN }}"
  HUB_USER: "${{ secrets.HUB_USER }}"
  DEV_BRANCH: main
  STG_BRANCH: staging
  PROD_BRANCH: production
  NPM_VERSION: 7.19.0
  # Hack for keeping npm's cache out of home directory (mounted from host)
  # otherwise, NPM gives EACCES error trying to mkdir /github/home/.npm
  npm_config_cache: /isolated_build/.npm-cache    
jobs:

  # dump_contexts_to_log:
  #   runs-on: ubuntu-latest
  #   steps:
  #     - name: Dump GitHub context
  #       env:
  #         GITHUB_CONTEXT: ${{ toJson(github) }}
  #       run: echo '$GITHUB_CONTEXT'
  #     - name: Dump job context
  #       env:
  #         JOB_CONTEXT: ${{ toJson(job) }}
  #       run: echo '$JOB_CONTEXT'
  #     - name: Dump steps context
  #       env:
  #         STEPS_CONTEXT: ${{ toJson(steps) }}
  #       run: echo '$STEPS_CONTEXT'
  #     - name: Dump runner context
  #       env:
  #         RUNNER_CONTEXT: ${{ toJson(runner) }}
  #       run: echo '$RUNNER_CONTEXT'
  #     - name: Dump strategy context
  #       env:
  #         STRATEGY_CONTEXT: ${{ toJson(strategy) }}
  #       run: echo '$STRATEGY_CONTEXT'
  #     - name: Dump matrix context
  #       env:
  #         MATRIX_CONTEXT: ${{ toJson(matrix) }}
  #       run: echo '$MATRIX_CONTEXT'


  # build-info:
  #   runs-on: [self-hosted, docker]
  #   container:
  #     image: node:14
  #   if: ${{ github.event_name }} != "push"
  #   timeout-minutes: 60
  #   steps:
  #     - name: Checkout repo into container
  #       run: |
  #         mkdir /isolated_build/ ; cd /isolated_build/
  #         httpsPathWithToken=`echo ${{github.repositoryUrl}} | awk '{ gsub(/git:\/\//, "\n" ); print "https://${{github.token}}@" $1; }'`
  #         echo Cloning from: $httpsPathWithToken
  #         git clone $httpsPathWithToken repo

  #     - run: |
  #         echo "This task give the CI/CD pipeline something to (almost always) run."
  #         echo "  CI_PIPELINE_SOURCE  = ${{ github.event_name }}"
  #         echo "  CI_MERGE_REQUEST_ID = ${{ github.event.pull_request.number }}"
  #         echo "  CI_COMMIT_BRANCH    = ${{ github.ref }}"
        
  # build-common:
  #   runs-on: [self-hosted, docker]
  #   container:
  #     image: node:14
  #   if: ${{ github.event.pull_request.number }} != null) || ${{ github.event_name }} == "schedule" || ${{ github.event_name }} == "web"
  #   timeout-minutes: 60
  #   steps:
  #   - name: Checkout repo into container
  #     run: |
  #       mkdir /isolated_build/ ; cd /isolated_build/
  #       httpsPathWithToken=`echo ${{github.repositoryUrl}} | awk '{ gsub(/git:\/\//, "\n" ); print "https://${{github.token}}@" $1; }'`
  #       echo Cloning from: $httpsPathWithToken
  #       git clone $httpsPathWithToken repo
  #   - name: Install NPM globally & Run 'npm ci'
  #     run:  |
  #       npm install -g npm@$NPM_VERSION --loglevel=verbose
  #       npm ci
  #     working-directory: /isolated_build/repo/common
  #   - name: Check code formatting
  #     run:  npx prettier --check .
  #     working-directory: /isolated_build/repo/common
  #   - name: Run TypeScript compiler
  #     run:  npx tsc
  #     working-directory: /isolated_build/repo/common
  #   - name: Run tests on ./common/
  #     run:  npm run test-ci
  #     working-directory: /isolated_build/repo/common

  # build-mobile:
  #   runs-on: [self-hosted, docker]
  #   container:
  #     image: node:14
  #   if: ${{ github.event.pull_request.number }} != null) || ${{ github.event_name }} == "schedule" || ${{ github.event_name }} == "web"
  #   timeout-minutes: 60
  #   steps:
  #   - name: Checkout repo into container
  #     run: |
  #       mkdir /isolated_build/ ; cd /isolated_build/
  #       httpsPathWithToken=`echo ${{github.repositoryUrl}} | awk '{ gsub(/git:\/\//, "\n" ); print "https://${{github.token}}@" $1; }'`
  #       echo Cloning from: $httpsPathWithToken
  #       git clone $httpsPathWithToken repo
  #   - name: Install NPM globally & Build mobile
  #     run:  |
  #       set -x  # echo commands names

  #       npm install -g npm@$NPM_VERSION
  #       npm uninstall @cbr/common
  #       COMMON_PACK_NAME=$(npm pack ../common | tail -n 1)
  #       npm install $COMMON_PACK_NAME
  #       npm ci
  #       npx prettier --check .
  #       npm run build dev
  #     working-directory: /isolated_build/repo/mobile


  # build-web:
  #   runs-on: [self-hosted, docker]
  #   container:
  #     image: node:14
  #   if: |
  #     ${{ github.event.pull_request.number }} != null) 
  #     || ${{ github.ref }} == $DEV_BRANCH 
  #     || ${{ github.ref }} == $STG_BRANCH 
  #     || ${{ github.ref }} == $PROD_BRANCH) 
  #     || ${{ github.event_name }} == "schedule" 
  #     || ${{ github.event_name }} == "web"
  #     timeout-minutes: 60
  #   steps:
  #   - name: Checkout repo into container
  #     run: |
  #       mkdir /isolated_build/ ; cd /isolated_build/
  #       httpsPathWithToken=`echo ${{github.repositoryUrl}} | awk '{ gsub(/git:\/\//, "\n" ); print "https://${{github.token}}@" $1; }'`
  #       echo Cloning from: $httpsPathWithToken
  #       git clone $httpsPathWithToken repo
  #   - name: Install NPM
  #     run:  npm install -g npm@$NPM_VERSION
  #   - name: Build common
  #     run:  npm ci
  #     working-directory: /isolated_build/repo/common
  #   - name: Build web
  #     run:  npm ci
  #     working-directory: /isolated_build/repo/web
  #   - name: Check code formatting
  #     run:  npx prettier --check .
  #     working-directory: /isolated_build/repo/web
  #   - name: Compress files
  #     run:  |
  #       GENERATE_SOURCEMAP=false npm run build
  #       cd build && tar -czvf ../../web_build.tar.gz .
  #     working-directory: /isolated_build/repo/web
  #   - uses: actions/upload-artifact@v3.1.1
  #     if: success()
  #     with:
  #       name: "${{ github.job }}"
  #       retention-days: 7
  #       path: /isolated_build/repo/web_build.tar.gz


  # build-server:
  #   runs-on: [self-hosted, docker]
  #   container:
  #     image: python:3.9.1-buster
  #   if: |
  #     ${{ github.event.pull_request.number }} != null) 
  #     || ${{ github.ref }} == $DEV_BRANCH 
  #     || ${{ github.ref }} == $STG_BRANCH 
  #     || ${{ github.ref }} == $PROD_BRANCH) 
  #     || ${{ github.event_name }} == "schedule" 
  #     || ${{ github.event_name }} == "web"
  #   timeout-minutes: 60
  #   services:
  #     test_postgres:
  #       image: postgres:13.1-alpine
  #   env:
  #     DOMAIN: example.com
  #     SECRET_KEY: test
  #     POSTGRES_DB: cbr
  #     POSTGRES_USER: test
  #     POSTGRES_PASSWORD: test
  #     POSTGRES_HOST: test_postgres
  #   steps:
  #   - name: Checkout repo into container
  #     run: |
  #       mkdir /isolated_build/ ; cd /isolated_build/
  #       httpsPathWithToken=`echo ${{github.repositoryUrl}} | awk '{ gsub(/git:\/\//, "\n" ); print "https://${{github.token}}@" $1; }'`
  #       echo Cloning from: $httpsPathWithToken
  #       git clone $httpsPathWithToken repo
  #   - name: Install dependencies
  #     run:  pip install -r requirements.txt
  #     working-directory: /isolated_build/repo/server
  #   - name: Check spacing
  #     run:  python -m black --check .
  #     working-directory: /isolated_build/repo/server
  #   - name: Run 'manage.py check'
  #     run:  python manage.py check
  #     working-directory: /isolated_build/repo/server
  #   - name: Run Migrations
  #     run:  python manage.py makemigrations --check
  #     working-directory: /isolated_build/repo/server
  #   - name: "TODO: SKIPPING TEST OF 'manage.py test'"
  #     run: |
  #       echo "::warning file=manage.py,title=SKIPPING TEST::Skipped manage.py test"
  #       # python manage.py test
  #     working-directory: /isolated_build/repo/server






  export-image-tag:
    runs-on: [self-hosted, docker]
    outputs:
      image_tag: ${{ steps.set_step.outputs.tag }}
    steps:
    - uses: actions/checkout@v3.5.0
      # Checkout the code, not into a container, because all work here is not in a container
      with:
        fetch-depth: 50
    - id: set_step
      run: |
        export IMAGE_TAG=v$(git show -s --format=%cs ${{ github.sha }}).`git rev-parse --short=8 ${{ github.sha }}`
        echo "IMAGE_TAG = '$IMAGE_TAG'"
        echo "tag=$IMAGE_TAG" >> "$GITHUB_OUTPUT"




  debug-image-tag:
    runs-on: [self-hosted, docker]
    needs: [export-image-tag]
    env:
      IMAGE_TAG: ${{ needs.export-image-tag.outputs.image_tag}}
    steps:
    - name: Test access tag
      run: echo "IMAGE_TAG = '$IMAGE_TAG'"

      
  build-docker-publish-docker-images:
    # needs: [build-common, build-mobile, build-web, build-server, export-image-tag]
    needs: [export-image-tag]
    runs-on: [self-hosted, docker]
    if: ${{ github.ref }} == $DEV_BRANCH || ${{ github.event_name }} == "web"
    timeout-minutes: 60
    env:
      IMAGE_TAG: ${{ needs.export-image-tag.outputs.image_tag}}
    steps:
    - uses: actions/checkout@v3.5.0
      # Checkout the code, not into a container, because all work here is not in a container
      with:
        fetch-depth: 50
    # - name: Get build products
    #   uses: actions/download-artifact@v3.0.1
    #   with:
    #     name: build-web
    - name: Get **FAKE** build products
      run: |
        echo "::warning file=web_build.tar.gz,title=FAKE::Fake web_build.tar.gz used for testing!"
        mkdir -p fakestuff/
        touch fakestuff/nothing.txt
        tar -czvf web_build.tar.gz ./fakestuff/
    - name: Printing debug information...
      run: |
        echo "Files in current folder before building image"
        ls -al
        echo "IMAGE_TAG = '$IMAGE_TAG'"
    - name: Running 'docker compose'...
      run: |
        docker compose -f docker-compose.yml -f docker-compose.deploy.yml build
        docker images
    - name: Pushing to docker hub...
      run: |
        docker login -u $HUB_USER -p $HUB_TOKEN
        docker push $HUB_USER/$HUB_REPO_BACKEND:$IMAGE_TAG
        docker push $HUB_USER/$HUB_REPO_FRONTEND:$IMAGE_TAG
        docker logout
        echo "::notice file=main-cicd.yml::Pushed to Docker Hub with IMAGE_TAG '$IMAGE_TAG'"
    - name: Cleaning up...
      run: |
        docker images -a | grep -e "$HUB_REPO_BACKEND" -e "$HUB_REPO_FRONTEND" | awk '{print $3}' | xargs docker rmi --force
        docker images

    












  # deploy-development-pre-script:
  #   needs: [build-docker-publish-docker-images]
  #   runs-on: [self-hosted, docker]
  #   if: ${{ github.ref }} == $DEV_BRANCH
  #   environment:
  #     name: development
  #     url: https://cbr-dev.cmpt.sfu.ca
  #   timeout-minutes: 60
  #   env:
  #     BRANCH_TAG: dev
  #   steps:
  #   - run: echo "IMAGE_TAG = '$IMAGE_TAG'"

    

    
    
  # dev-server-deploy-from-dockerhub:
  #   needs: [build-docker-publish-docker-images]
  #   runs-on: [self-hosted, deploy-development]
  #   if: ${{ github.ref }} == $DEV_BRANCH
  #   environment:
  #     name: development
  #     url: https://cbr-dev.cmpt.sfu.ca
  #   timeout-minutes: 60
  #   env:
  #     BRANCH_TAG: dev
  #   uses: ./.github/workflows/deploy-from-dockerhub.yml
  #     with:
  #       config-path: deploy-development
  
  # dev-retag-and-upload-to-dockerhub:
  #   # needs: [build-docker-publish-docker-images, export-image-tag]
  #   runs-on: [self-hosted, docker]
  #   # if: ${{ github.ref }} == $DEV_BRANCH
  #   # environment:
  #   #   name: development
  #   #   url: https://cbr-dev.cmpt.sfu.ca
  #   # timeout-minutes: 60
  #   # env:
  #   #   BRANCH_TAG: dev
  #   #   IMAGE_TAG: ${{ needs.export-image-tag.outputs.image_tag}}
  #   uses: ./.github/workflows/retag-and-upload-dockerhub.yml
  #   with:
  #     IMAGE_TAG:  Da-Image-Tag-Here #$IMAGE_TAG
  #     BRANCH_TAG: dev
  #   secrets: inherit


  working-version:
    uses: ./.github/workflows/retag-and-upload-dockerhub.yml
    with:
      IMAGE_TAG:  Da-Image-Tag-Here #$IMAGE_TAG
      BRANCH_TAG: dev
    secrets: inherit


  get-all-correct-info:
    needs: [export-image-tag]
    env:
      IMAGE_TAG: ${{ needs.export-image-tag.outputs.image_tag}}
    uses: ./.github/workflows/retag-and-upload-dockerhub.yml
    with:
      IMAGE_TAG:  $IMAGE_TAG
      BRANCH_TAG: dev
    secrets: inherit


  # YES: GitHub detects that the file does not exist.
  # small-test2:
  #   uses: ./.github/workflows/BADFILE.yml
  #   with:
  #     IMAGE_TAG:  Da-Image-Tag-Here #$IMAGE_TAG
  #     BRANCH_TAG: dev
  #   secrets: inherit

  #  YES: GitHUb correctly detects missing parameters
  # small-test3:
  #   uses: ./.github/workflows/retag-and-upload-dockerhub.yml

  # small-test4:
  #   uses: ./.github/workflows/retag-and-upload-dockerhub.yml
  #   with:
  #     IMAGE_TAG:  Da-Image-Tag-Here #$IMAGE_TAG
  #     BRANCH_TAG: dev
  #   secrets: inherit






#   deploy-staging-pre-script:
#     needs: [test-common, test-caddy]
#     runs-on: [self-hosted, deploy-development]
#     if: ${{ github.ref }} == $STG_BRANCH
#     environment:
#       name: staging
#       url: https://cbr-stg.cmpt.sfu.ca
#     timeout-minutes: 60
#     env:
#       BRANCH_TAG: dev
#     steps:
#     - uses: actions/checkout@v3.5.0
#       with:
#         fetch-depth: 50
#     - uses: actions/download-artifact@v3.0.1
    
#   deploy-staging-from-dockerhub:
#     needs: [deploy-staging-pre-script]
#     uses: vbui512/test/.github/workflows/deploy-from-dockerhub.yml@d201cb9781b92ae1774aba6af6346c5858b362f7
#     with:
#       config-path: deploy-staging
  
#   retag-and-upload-staging:
#     needs: [deploy-staging-pre-script]
#     uses: vbui512/test/.github/workflows/retag-and-upload-dockerhub.yml@5614cff34c39637e3bb5f7fd1add8f2db381abf8
#     with:
#       config-path: deploy-staging
      






#   deploy-production-pre-script:
#     needs: [test-common, test-caddy]
#     runs-on: [self-hosted, deploy-dockerhub-shell]
#     if: ${{ github.ref }} == $PROD_BRANCH
#     environment:
#       name: staging
#       url: https://cbr-stg.cmpt.sfu.ca
#     timeout-minutes: 60
#     env:
#       BRANCH_TAG: dev
#     steps:
#     - uses: actions/checkout@v3.5.0
#       with:
#         fetch-depth: 50
#     - uses: actions/download-artifact@v3.0.1
  
#   retag-and-upload-production:
#     needs: [deploy-production-pre-script]
#     uses: vbui512/test/.github/workflows/retag-and-upload-dockerhub.yml@5614cff34c39637e3bb5f7fd1add8f2db381abf8
#     with:
#       config-path: deploy-dockerhub-shell

 
